package de.mhus.nimbus.world.life.redis;

import com.fasterxml.jackson.databind.ObjectMapper;
import de.mhus.nimbus.generated.types.EntityPathway;
import de.mhus.nimbus.shared.types.WorldId;
import de.mhus.nimbus.world.life.model.ChunkCoordinate;
import de.mhus.nimbus.world.shared.redis.PathwayBroadcastMessage;
import de.mhus.nimbus.world.shared.redis.WorldRedisMessagingService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Publishes entity pathways to world-player pods via Redis.
 * Channel: world:{worldId}:e.p
 *
 * Pathways are generated by SimulatorService and distributed to world-player pods.
 * Each world-player pod filters pathways based on session chunk registrations
 * and sends relevant pathways to connected clients.
 *
 * Message format:
 * {
 *   "pathways": [{EntityPathway}, ...],
 *   "affectedChunks": [{"cx": 6, "cz": -13}, ...]
 * }
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class PathwayPublisher {

    private final WorldRedisMessagingService redisMessaging;
    private final ObjectMapper objectMapper;

    /**
     * Publish entity pathways to Redis for distribution to clients.
     *
     * @param worldId World ID
     * @param pathways List of entity pathways
     * @param affectedChunks Chunks that contain these pathways
     */
    public void publishPathways(WorldId worldId, List<EntityPathway> pathways, Set<ChunkCoordinate> affectedChunks) {
        if (pathways == null || pathways.isEmpty()) {
            return;
        }

        try {
            // Convert to PathwayBroadcastMessage format
            List<PathwayBroadcastMessage.PathwayContainer> containers = pathways.stream()
                    .map(pathway -> PathwayBroadcastMessage.PathwayContainer.builder()
                            .pathway(pathway)
                            .sessionId(null) // NPC pathways have no originating session
                            .worldId(worldId.getId())
                            .build())
                    .collect(Collectors.toList());

            List<PathwayBroadcastMessage.ChunkCoordinate> chunks = affectedChunks.stream()
                    .map(chunk -> new PathwayBroadcastMessage.ChunkCoordinate(chunk.getCx(), chunk.getCz()))
                    .collect(Collectors.toList());

            PathwayBroadcastMessage message = PathwayBroadcastMessage.builder()
                    .containers(containers)
                    .affectedChunks(chunks)
                    .build();

            // Serialize and publish
            String json = objectMapper.writeValueAsString(message);
            redisMessaging.publish(worldId.getId(), "e.p", json);

            log.debug("World {}: Published {} pathways to Redis, affecting {} chunks",
                    worldId, pathways.size(), affectedChunks.size());

        } catch (Exception e) {
            log.error("World {}: Failed to publish pathways to Redis: {} pathways", worldId, pathways.size(), e);
        }
    }

    /**
     * Publish a single pathway.
     *
     * @param worldId World ID
     * @param pathway Entity pathway
     * @param affectedChunks Chunks affected by this pathway
     */
    public void publishPathway(WorldId worldId, EntityPathway pathway, Set<ChunkCoordinate> affectedChunks) {
        publishPathways(worldId, List.of(pathway), affectedChunks);
    }
}
