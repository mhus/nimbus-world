package de.mhus.nimbus.tools.generatej2ts.ts;

import org.apache.maven.plugin.logging.Log;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.util.List;

/**
 * Schreibt ein TypeScriptModel als einzelne .ts Dateien auf die Platte.
 *
 * Regeln (minimal):
 * - Jeder Typ → eine Datei "Name.ts" (ggf. in Subfolder aus dem Model)
 * - Imports (falls vorhanden) werden an den Anfang geschrieben
 * - Klassen werden als "export interface Name { ... }" ausgegeben
 * - Enums als "export enum Name { A, B, C }"
 * - optionale Felder mit ? (z.B. foo?: string;)
 */
public class TypeScriptModelWriter {

    private final Log log;

    public TypeScriptModelWriter(Log log) {
        this.log = log;
    }

    public void writeModel(TypeScriptModel model, File outputDir) throws IOException {
        if (model == null) return;
        if (outputDir == null) throw new IOException("outputDir ist null");
        if (!outputDir.exists() && !outputDir.mkdirs()) {
            throw new IOException("Kann Ausgabeverzeichnis nicht anlegen: " + outputDir.getAbsolutePath());
        }

        int count = 0;
        for (TypeScriptType type : model.getTypes()) {
            if (type == null) continue;
            File dir = outputDir;
            if (type.getSubfolder() != null && !type.getSubfolder().isBlank()) {
                dir = new File(outputDir, type.getSubfolder());
                if (!dir.exists() && !dir.mkdirs()) {
                    throw new IOException("Kann Subfolder nicht anlegen: " + dir.getAbsolutePath());
                }
            }
            String fileName = type.getFileName();
            if (fileName == null || fileName.isBlank()) fileName = type.getName() + ".ts";
            File out = new File(dir, fileName);
            writeTypeFile(type, out);
            count++;
        }
        if (log != null) log.info("TypeScriptModelWriter: Dateien geschrieben: " + count + " in " + outputDir.getAbsolutePath());
    }

    private void writeTypeFile(TypeScriptType type, File out) throws IOException {
        try (Writer w = new OutputStreamWriter(new FileOutputStream(out), StandardCharsets.UTF_8)) {
            // Header-Kommentar inkl. Java-Quellklasse (Package + Name)
            String src = type.getSourceFqn();
            if (src == null || src.isBlank()) src = type.getName();
            w.write("/*\n");
            w.write(" Auto-generated by generate-java-to-ts-maven-plugin. Do not edit.\n");
            w.write(" Source: " + src + "\n");
            w.write("*/\n\n");

            // Imports
            if (type.getImports() != null && !type.getImports().isEmpty()) {
                for (String imp : type.getImports()) {
                    if (imp == null || imp.isBlank()) continue;
                    w.write(imp);
                    if (!imp.endsWith("\n")) w.write("\n");
                }
                w.write("\n");
            }

            // Konstanten (aus static final Feldern)
            if (type.getConstants() != null && !type.getConstants().isEmpty()) {
                writeConstants(type.getConstants(), w);
                w.write("\n");
            }

            if (type.getKind() == TypeScriptKind.ENUM) {
                writeEnum(type, w);
            } else {
                // Write nested enums first (if any)
                if (type.getNestedEnums() != null && !type.getNestedEnums().isEmpty()) {
                    for (TypeScriptNestedEnum ne : type.getNestedEnums()) {
                        writeNestedEnum(ne, w);
                        w.write("\n");
                    }
                }
                writeInterface(type, w);
            }
        }
    }

    private void writeInterface(TypeScriptType type, Writer w) throws IOException {
        w.write("export interface " + type.getName() + " {\n");
        for (TypeScriptField f : type.getFields()) {
            if (f == null) continue;
            String opt = f.isOptional() ? "?" : "";
            String t = f.getTsType() == null || f.getTsType().isBlank() ? "any" : f.getTsType();
            String desc = f.getDescription();
            if (desc != null) {
                desc = desc.trim();
                // Sicherheitsmaßnahme: Blockkommentar nicht unbeabsichtigt schließen lassen
                desc = desc.replace("*/", "* /");
            }
            w.write("  " + f.getName() + opt + ": " + t + ";");
            if (desc != null && !desc.isEmpty()) {
                w.write(" /* " + desc + " */");
            }
            w.write("\n");
        }
        w.write("}\n");
    }

    private void writeEnum(TypeScriptType type, Writer w) throws IOException {
        w.write("export enum " + type.getName() + " {\n");
        for (int i = 0; i < type.getEnumValues().size(); i++) {
            String v = type.getEnumValues().get(i);
            w.write("  " + v);
            if (i < type.getEnumValues().size() - 1) w.write(",");
            w.write("\n");
        }
        w.write("}\n");
    }

    private void writeNestedEnum(TypeScriptNestedEnum ne, Writer w) throws IOException {
        w.write("export enum " + ne.getName() + " {\n");
        for (int i = 0; i < ne.getValues().size(); i++) {
            String v = ne.getValues().get(i);
            w.write("  " + v);
            if (i < ne.getValues().size() - 1) w.write(",");
            w.write("\n");
        }
        w.write("}\n");
    }

    private void writeConstants(List<TypeScriptConstant> constants, Writer w) throws IOException {
        for (TypeScriptConstant c : constants) {
            if (c == null) continue;
            String name = c.getName();
            String value = c.getValue();
            String type = c.getTsType();
            if (value != null && !value.isBlank()) {
                w.write("export const " + name + " = " + value + ";\n");
            } else {
                // Falls kein Wert vorhanden ist, mit Typ annotieren
                String t = (type == null || type.isBlank()) ? "any" : type;
                w.write("export const " + name + ": " + t + ";\n");
            }
        }
    }
}
