package de.mhus.nimbus.world.generator.flat.hexgrid.composer;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import de.mhus.nimbus.generated.types.HexVector2;
import lombok.Data;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Data
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "featureType")
@JsonSubTypes({
    @JsonSubTypes.Type(value = Biome.class, name = "biome"),
    @JsonSubTypes.Type(value = MountainBiome.class, name = "mountain-biome"),
    @JsonSubTypes.Type(value = ForestBiome.class, name = "forest-biome"),
    @JsonSubTypes.Type(value = PlainsBiome.class, name = "plains-biome"),
    @JsonSubTypes.Type(value = DesertBiome.class, name = "desert-biome"),
    @JsonSubTypes.Type(value = SwampBiome.class, name = "swamp-biome"),
    @JsonSubTypes.Type(value = CoastBiome.class, name = "coast-biome"),
    @JsonSubTypes.Type(value = IslandBiome.class, name = "island-biome"),
    @JsonSubTypes.Type(value = OceanBiome.class, name = "ocean-biome"),
    @JsonSubTypes.Type(value = Village.class, name = "village"),
    @JsonSubTypes.Type(value = Town.class, name = "town"),
    @JsonSubTypes.Type(value = Composite.class, name = "composite"),
    @JsonSubTypes.Type(value = Road.class, name = "road"),
    @JsonSubTypes.Type(value = River.class, name = "river"),
    @JsonSubTypes.Type(value = Wall.class, name = "wall"),
    @JsonSubTypes.Type(value = SideWall.class, name = "sidewall"),
    @JsonSubTypes.Type(value = Point.class, name = "point")
})
public abstract class Feature {
    private String featureId;
    private String name;
    private String title;
    private FeatureStatus status;
    private Boolean enabled;
    private String description;
    private Map<String, String> metadata;

    /**
     * List of HexGrid configurations created for this feature.
     * Stores coordinates and parameters, NOT the actual WHexGrid instances.
     * Only populated after BiomeComposer/HexGridFiller stage (status >= COMPOSED).
     */
    private List<FeatureHexGrid> hexGrids;

    public void initialize() {
        if (featureId == null || featureId.isBlank()) {
            featureId = UUID.randomUUID().toString();
        }
        if (status == null) {
            status = FeatureStatus.NEW;
        }
        if (enabled == null) {
            enabled = true;
        }

        // Apply type-specific defaults (polymorphic - subclasses override)
        applyDefaults();
    }

    /**
     * Applies default configuration for this feature type.
     * Override in subclasses for type-specific defaults.
     */
    public void applyDefaults() {
        // Base implementation does nothing - override in subclasses
    }

    /**
     * Returns true if this feature was auto-generated by filler (Ocean, Land, Coast)
     */
    public boolean isGenerated() {
        return metadata != null && "true".equals(metadata.get("generated"));
    }

    /**
     * Marks this feature as auto-generated by filler
     */
    public void markAsGenerated() {
        if (metadata == null) {
            metadata = new java.util.HashMap<>();
        }
        metadata.put("generated", "true");
    }

    public String getDisplayTitle() {
        return title != null ? title : name;
    }

    /**
     * Adds a HexGrid configuration to this feature
     */
    public void addHexGrid(FeatureHexGrid hexGrid) {
        if (hexGrids == null) {
            hexGrids = new ArrayList<>();
        }
        hexGrids.add(hexGrid);
    }

    /**
     * Returns all HexGrid configurations for this feature
     */
    public List<FeatureHexGrid> getHexGrids() {
        return hexGrids != null ? hexGrids : new ArrayList<>();
    }

    /**
     * Finds a HexGrid configuration by coordinate
     */
    public FeatureHexGrid findHexGrid(HexVector2 coordinate) {
        if (hexGrids == null || coordinate == null) return null;
        return hexGrids.stream()
            .filter(hg -> hg.getCoordinate() != null
                && hg.getCoordinate().getQ() == coordinate.getQ()
                && hg.getCoordinate().getR() == coordinate.getR())
            .findFirst()
            .orElse(null);
    }

    /**
     * Returns true if this feature has HexGrids that need to be created
     */
    public boolean needsHexGridCreation() {
        return status == FeatureStatus.COMPOSED && enabled == Boolean.TRUE;
    }

    /**
     * Returns true if HexGrids have been created in database
     */
    public boolean hasCreatedHexGrids() {
        return status == FeatureStatus.CREATED;
    }
}
