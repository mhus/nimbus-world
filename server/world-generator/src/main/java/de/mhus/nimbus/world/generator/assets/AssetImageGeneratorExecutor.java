package de.mhus.nimbus.world.generator.assets;

import de.mhus.nimbus.shared.service.SSettingsService;
import de.mhus.nimbus.shared.settings.SettingInteger;
import de.mhus.nimbus.shared.settings.SettingString;
import de.mhus.nimbus.shared.types.WorldId;
import de.mhus.nimbus.world.ai.image.AiImage;
import de.mhus.nimbus.world.ai.image.AiImageException;
import de.mhus.nimbus.world.ai.image.AiImageModel;
import de.mhus.nimbus.world.ai.image.AiImageOptions;
import de.mhus.nimbus.world.ai.model.AiModelService;
import de.mhus.nimbus.world.shared.job.JobExecutionException;
import de.mhus.nimbus.world.shared.job.JobExecutor;
import de.mhus.nimbus.world.shared.job.WJob;
import de.mhus.nimbus.world.shared.archive.WArchiveService;
import de.mhus.nimbus.world.shared.world.AssetMetadata;
import de.mhus.nimbus.world.shared.world.SAsset;
import de.mhus.nimbus.world.shared.world.SAssetService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import jakarta.annotation.PostConstruct;
import javax.imageio.ImageIO;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.util.Optional;

/**
 * Job executor that generates AI images for game assets.
 * Creates new images/textures based on text prompts and saves them to SAssets.
 * <p>
 * The prompt is used directly without any automatic enhancement or modification.
 * This allows full control over the AI generation style and content.
 * <p>
 * Job parameters:
 * <ul>
 *     <li>prompt (required) - Text description of the image (used as-is, no automatic enhancement)</li>
 *     <li>path (required) - Asset path where image will be saved (e.g., "textures/blocks/stone.png")</li>
 *     <li>size (optional) - Image size in pixels (default: 16x16, format: "16x16")</li>
 *     <li>quality (optional) - Image quality: "standard" or "hd" (default: "standard")</li>
 *     <li>style (optional) - Image style: "vivid" or "natural" (default: "vivid")</li>
 *     <li>cropBorder (optional) - Crop pixels from each side before resize (default: 0, e.g., "70" crops 70px from each side)</li>
 *     <li>resize (optional) - Resize image to requested size if different (default: true)</li>
 *     <li>transparency (optional) - Make color transparent: "false" (default), "true"/"black", "white", "blue", "red", "green"</li>
 *     <li>generateDescription (optional) - Generate AI description after saving (default: true)</li>
 *     <li>overwrite (optional) - Overwrite existing asset if path exists (default: false)</li>
 * </ul>
 * <p>
 * Processing order:
 * <ol>
 *     <li>Generate image with AI</li>
 *     <li>Archive original image</li>
 *     <li>Crop border if cropBorder > 0</li>
 *     <li>Resize to target size if resize=true</li>
 *     <li>Make color transparent if transparency != "false"</li>
 *     <li>Save to assets</li>
 *     <li>Generate description if generateDescription=true</li>
 * </ol>
 * <p>
 * If overwrite=false and path already exists, a unique path will be generated by appending a number:
 * <ul>
 *     <li>textures/snow.png -> textures/snow-1.png (if snow.png exists)</li>
 *     <li>textures/snow-1.png -> textures/snow-2.png (if snow-1.png exists)</li>
 * </ul>
 */
@Component
@Slf4j
@RequiredArgsConstructor
public class AssetImageGeneratorExecutor implements JobExecutor {

    private static final String EXECUTOR_NAME = "asset-image-generator";
    private static final int DEFAULT_SIZE = 16;

    private final SAssetService assetService;
    private final AiModelService aiModelService;
    private final SSettingsService settingsService;
    private final AssetDescriptionGeneratorExecutor descriptionGenerator;
    private final WArchiveService archiveService;

    @Value("${asset.image.ai-model:default:generate}")
    private String aiModelName;

    // AI image generation settings (loaded dynamically from SSettingsService)
    private SettingInteger timeoutSeconds;
    private SettingString defaultQuality;
    private SettingString defaultStyle;

    @PostConstruct
    private void initSettings() {
        timeoutSeconds = settingsService.getInteger("asset.image.timeout-seconds", 120);
        defaultQuality = settingsService.getString("asset.image.quality", "standard");
        defaultStyle = settingsService.getString("asset.image.style", "vivid");

        log.info("Asset image generation settings initialized: timeoutSeconds={}, quality={}, style={}",
                timeoutSeconds.get(), defaultQuality.get(), defaultStyle.get());
    }

    @Override
    public String getExecutorName() {
        return EXECUTOR_NAME;
    }

    @Override
    public JobResult execute(WJob job) throws JobExecutionException {
        try {
            // Get worldId from job
            String worldIdStr = job.getWorldId();
            if (worldIdStr == null || worldIdStr.isBlank()) {
                throw new JobExecutionException("Job has no worldId");
            }

            WorldId worldId = WorldId.of(worldIdStr)
                    .orElseThrow(() -> new JobExecutionException("Invalid worldId: " + worldIdStr));

            // Get required parameters
            String prompt = job.getParameters().get("prompt");
            if (prompt == null || prompt.isBlank()) {
                throw new JobExecutionException("Parameter 'prompt' is required");
            }

            String path = job.getParameters().get("path");
            if (path == null || path.isBlank()) {
                throw new JobExecutionException("Parameter 'path' is required");
            }

            // Get optional parameters
            String sizeStr = job.getParameters().getOrDefault("size", DEFAULT_SIZE + "x" + DEFAULT_SIZE);
            String quality = job.getParameters().getOrDefault("quality", defaultQuality.get());
            String style = job.getParameters().getOrDefault("style", defaultStyle.get());
            boolean resize = Boolean.parseBoolean(job.getParameters().getOrDefault("resize", "true"));
            boolean generateDescription = Boolean.parseBoolean(job.getParameters().getOrDefault("generateDescription", "true"));
            boolean overwrite = Boolean.parseBoolean(job.getParameters().getOrDefault("overwrite", "false"));
            int cropBorder = Integer.parseInt(job.getParameters().getOrDefault("cropBorder", "0"));
            String transparency = job.getParameters().getOrDefault("transparency", "false");

            // Find unique path if requested path already exists (unless overwrite=true)
            String uniquePath = path;
            if (!overwrite) {
                uniquePath = findUniquePath(worldId, path);
                if (!uniquePath.equals(path)) {
                    log.info("Path already exists, using unique path: {} -> {}", path, uniquePath);
                }
            } else if (assetExists(worldId, path)) {
                log.info("Overwriting existing asset at path: {}", path);
            }

            // Parse size
            int[] dimensions = parseSize(sizeStr);
            int width = dimensions[0];
            int height = dimensions[1];

            log.info("Generating image: world={}, path={}, prompt='{}', size={}x{}, quality={}, style={}",
                    worldId.getId(), uniquePath, prompt, width, height, quality, style);

            // Create AI image model
            AiImageOptions options = AiImageOptions.builder()
                    .width(width)
                    .height(height)
                    .quality(quality)
                    .style(style)
                    .responseFormat("url") // Download bytes for storage
                    .timeoutSeconds(timeoutSeconds.get())
                    .logRequests(false)
                    .build();

            Optional<AiImageModel> imageModelOpt = aiModelService.createImageModel(aiModelName, options);
            if (imageModelOpt.isEmpty()) {
                throw new JobExecutionException("Failed to create AI image model: " + aiModelName);
            }

            AiImageModel imageModel = imageModelOpt.get();
            log.info("Using AI image model: {}", imageModel.getName());

            // Generate image
            AiImage image = generateImage(imageModel, prompt, width, height);

            // Archive original image before any processing
            archiveOriginalImage(image, uniquePath);

            // Crop border if requested
            if (cropBorder > 0) {
                image = cropImageBorder(image, cropBorder, uniquePath);
            }

            // Resize image if needed and requested
            if (resize) {
                image = resizeImageIfNeeded(image, width, height, uniquePath);
            }

            // Make color transparent if requested
            if (transparency != null && !transparency.equalsIgnoreCase("false")) {
                image = makeColorTransparent(image, transparency, uniquePath);
            }

            // Save to SAssets
            SAsset savedAsset = saveImage(worldId, uniquePath, image, prompt);
            assetService.updateMetadata(savedAsset, savedAsset.getPublicData());

            // Generate AI description if requested
            if (generateDescription) {
                generateAssetDescription(savedAsset);
            }

            String message = String.format("Generated image: %s (%dx%d) - '%s'",
                    uniquePath, width, height, prompt);
            log.info(message);
            return JobResult.success(message);

        } catch (Exception e) {
            log.error("Image generation failed", e);
            throw new JobExecutionException("Generation failed: " + e.getMessage(), e);
        }
    }

    /**
     * Generate image using AI image model.
     *
     * @param imageModel AI image model
     * @param prompt Text description
     * @param width Image width
     * @param height Image height
     * @return Generated image
     * @throws JobExecutionException if generation fails
     */
    private AiImage generateImage(AiImageModel imageModel, String prompt, int width, int height)
            throws JobExecutionException {
        try {
            log.debug("Generating image with prompt: {}", prompt);

            // Generate image with original prompt (no enhancement)
            AiImage image = imageModel.generate(prompt, width, height);

            if (image == null) {
                throw new JobExecutionException("AI model returned null image");
            }

            // Check if we have image data
            if (!image.hasBytes() && !image.hasUrl()) {
                throw new JobExecutionException("Generated image has no data (neither bytes nor URL)");
            }

            return image;

        } catch (AiImageException e) {
            log.error("Failed to generate image: prompt={}", prompt, e);
            throw new JobExecutionException("Image generation failed: " + e.getMessage(), e);
        }
    }

    /**
     * Generate AI description for the saved asset.
     *
     * @param asset The saved asset
     */
    private void generateAssetDescription(SAsset asset) {
        try {
            log.info("Generating AI description for asset: {}", asset.getPath());

            boolean success = descriptionGenerator.generateDescriptionForAsset(asset);

            if (success) {
                log.info("Successfully generated description for asset: {}", asset.getPath());
            } else {
                log.warn("Failed to generate description for asset: {}", asset.getPath());
            }

        } catch (Exception e) {
            log.error("Error generating description for asset: {}", asset.getPath(), e);
            // Don't throw exception - description generation is optional
        }
    }

    /**
     * Save generated image to SAssets.
     *
     * @param worldId World ID
     * @param path Asset path
     * @param image Generated image
     * @param originalPrompt Original generation prompt
     * @return Saved asset
     * @throws JobExecutionException if save fails
     */
    private SAsset saveImage(WorldId worldId, String path, AiImage image, String originalPrompt) throws JobExecutionException {
        try {
            // Get image bytes
            byte[] imageBytes = image.getBytes();
            if (imageBytes == null || imageBytes.length == 0) {
                throw new JobExecutionException("No image bytes available");
            }

            // Read actual image dimensions from bytes
            ByteArrayInputStream dimCheckStream = new ByteArrayInputStream(imageBytes);
            BufferedImage bufferedImage = ImageIO.read(dimCheckStream);

            if (bufferedImage == null) {
                throw new JobExecutionException("Failed to decode image bytes");
            }

            int actualWidth = bufferedImage.getWidth();
            int actualHeight = bufferedImage.getHeight();

            log.debug("Image dimensions: requested={}x{}, actual={}x{}",
                    image.getWidth(), image.getHeight(), actualWidth, actualHeight);

            // Determine MIME type
            String mimeType = image.getMimeType();
            if (mimeType == null || mimeType.isBlank()) {
                // Fallback: detect from path
                mimeType = getMimeTypeFromPath(path);
            }

            // Create asset metadata
            AssetMetadata metadata = new AssetMetadata();

            // Set description (use revised prompt if available)
            if (image.getRevisedPrompt() != null && !image.getRevisedPrompt().isBlank()) {
                metadata.setDescription("AI-generated image: " + image.getRevisedPrompt());
            } else {
                metadata.setDescription("AI-generated image");
            }

            metadata.setMimeType(mimeType);
            metadata.setWidth(actualWidth);
            metadata.setHeight(actualHeight);
            metadata.setSource("AI Generated");
            metadata.setAuthor("DALL-E");
            metadata.setLicense("CC0");
            metadata.setLicenseFixed(true);

            // Store original prompt as custom property
            if (originalPrompt != null && !originalPrompt.isBlank()) {
                metadata.setProperty("prompt", originalPrompt);
            }

            // Create asset
            ByteArrayInputStream inputStream = new ByteArrayInputStream(imageBytes);
            SAsset asset = assetService.saveAsset(worldId, path, inputStream, "AI-Generator", metadata);

            if (asset == null) {
                throw new JobExecutionException("Asset service returned null");
            }

            log.info("Saved image to assets: path={}, size={} bytes, dimensions={}x{}, mimeType={}, assetId={}",
                    path, imageBytes.length, actualWidth, actualHeight, mimeType, asset.getId());

            return asset;

        } catch (Exception e) {
            log.error("Failed to save image: path={}", path, e);
            throw new JobExecutionException("Failed to save image: " + e.getMessage(), e);
        }
    }

    /**
     * Resize image if dimensions don't match requested size.
     *
     * @param image Original image
     * @param targetWidth Target width
     * @param targetHeight Target height
     * @param path Asset path for logging
     * @return Resized image or original if already correct size
     * @throws JobExecutionException if resize fails
     */
    private AiImage resizeImageIfNeeded(AiImage image, int targetWidth, int targetHeight, String path)
            throws JobExecutionException {

        // Check if resize is needed
        if (image.getWidth() == targetWidth && image.getHeight() == targetHeight) {
            log.debug("Image already has correct size: {}x{}", targetWidth, targetHeight);
            return image;
        }

        log.info("Resizing image from {}x{} to {}x{} for path: {}",
                image.getWidth(), image.getHeight(), targetWidth, targetHeight, path);

        try {
            // Get image bytes
            byte[] originalBytes = image.getBytes();
            if (originalBytes == null || originalBytes.length == 0) {
                throw new JobExecutionException("Cannot resize: no image bytes available");
            }

            // Load image
            ByteArrayInputStream inputStream = new ByteArrayInputStream(originalBytes);
            BufferedImage originalImage = ImageIO.read(inputStream);

            if (originalImage == null) {
                throw new JobExecutionException("Cannot resize: failed to decode image");
            }

            // Resize image
            Image scaledImage = originalImage.getScaledInstance(
                    targetWidth,
                    targetHeight,
                    Image.SCALE_SMOOTH
            );

            // Convert to BufferedImage
            BufferedImage resizedImage = new BufferedImage(
                    targetWidth,
                    targetHeight,
                    BufferedImage.TYPE_INT_ARGB
            );
            resizedImage.getGraphics().drawImage(scaledImage, 0, 0, null);

            // Encode to bytes
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            String format = getImageFormat(image.getMimeType());
            ImageIO.write(resizedImage, format, outputStream);
            byte[] resizedBytes = outputStream.toByteArray();

            // Create new AiImage with resized data
            return AiImage.builder()
                    .bytes(resizedBytes)
                    .mimeType(image.getMimeType())
                    .width(targetWidth)
                    .height(targetHeight)
                    .revisedPrompt(image.getRevisedPrompt())
                    .build();

        } catch (Exception e) {
            log.error("Failed to resize image: {}x{} -> {}x{}",
                    image.getWidth(), image.getHeight(), targetWidth, targetHeight, e);
            throw new JobExecutionException("Failed to resize image: " + e.getMessage(), e);
        }
    }

    /**
     * Crop border from all sides of the image.
     * <p>
     * Removes specified number of pixels from each side (left, right, top, bottom).
     * This is useful to remove unwanted borders or artifacts from AI-generated images.
     *
     * @param image Original image
     * @param borderSize Number of pixels to crop from each side
     * @param path Asset path for logging
     * @return Cropped image
     * @throws JobExecutionException if crop fails
     */
    private AiImage cropImageBorder(AiImage image, int borderSize, String path)
            throws JobExecutionException {

        if (borderSize <= 0) {
            return image;
        }

        log.info("Cropping {}px border from image ({}x{}) for path: {}",
                borderSize, image.getWidth(), image.getHeight(), path);

        try {
            // Get image bytes
            byte[] originalBytes = image.getBytes();
            if (originalBytes == null || originalBytes.length == 0) {
                throw new JobExecutionException("Cannot crop: no image bytes available");
            }

            // Load image
            ByteArrayInputStream inputStream = new ByteArrayInputStream(originalBytes);
            BufferedImage originalImage = ImageIO.read(inputStream);

            if (originalImage == null) {
                throw new JobExecutionException("Cannot crop: failed to decode image");
            }

            int originalWidth = originalImage.getWidth();
            int originalHeight = originalImage.getHeight();

            // Calculate cropped dimensions
            int croppedWidth = originalWidth - (2 * borderSize);
            int croppedHeight = originalHeight - (2 * borderSize);

            // Validate dimensions
            if (croppedWidth <= 0 || croppedHeight <= 0) {
                throw new JobExecutionException(String.format(
                        "Cannot crop: border size %d is too large for image size %dx%d (resulting size would be %dx%d)",
                        borderSize, originalWidth, originalHeight, croppedWidth, croppedHeight));
            }

            log.debug("Cropping from {}x{} to {}x{} (border={}px)",
                    originalWidth, originalHeight, croppedWidth, croppedHeight, borderSize);

            // Crop image
            BufferedImage croppedImage = originalImage.getSubimage(
                    borderSize,           // x
                    borderSize,           // y
                    croppedWidth,         // width
                    croppedHeight         // height
            );

            // Encode to bytes
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            String format = getImageFormat(image.getMimeType());
            ImageIO.write(croppedImage, format, outputStream);
            byte[] croppedBytes = outputStream.toByteArray();

            // Create new AiImage with cropped data
            return AiImage.builder()
                    .bytes(croppedBytes)
                    .mimeType(image.getMimeType())
                    .width(croppedWidth)
                    .height(croppedHeight)
                    .revisedPrompt(image.getRevisedPrompt())
                    .build();

        } catch (Exception e) {
            log.error("Failed to crop image: {}x{} with border {}px",
                    image.getWidth(), image.getHeight(), borderSize, e);
            throw new JobExecutionException("Failed to crop image: " + e.getMessage(), e);
        }
    }

    /**
     * Get image format from MIME type.
     *
     * @param mimeType MIME type
     * @return Image format (e.g., "png", "jpeg")
     */
    private String getImageFormat(String mimeType) {
        if (mimeType == null) return "png";

        if (mimeType.contains("png")) return "png";
        if (mimeType.contains("jpeg") || mimeType.contains("jpg")) return "jpeg";
        if (mimeType.contains("gif")) return "gif";
        if (mimeType.contains("bmp")) return "bmp";
        if (mimeType.contains("webp")) return "webp";

        return "png"; // Default
    }

    /**
     * Parse size string (e.g., "16x16", "512x512").
     *
     * @param sizeStr Size string
     * @return Array with [width, height]
     * @throws JobExecutionException if format is invalid
     */
    private int[] parseSize(String sizeStr) throws JobExecutionException {
        try {
            String[] parts = sizeStr.toLowerCase().split("x");
            if (parts.length != 2) {
                throw new JobExecutionException("Invalid size format: " + sizeStr + " (expected: WxH, e.g., 16x16)");
            }

            int width = Integer.parseInt(parts[0].trim());
            int height = Integer.parseInt(parts[1].trim());

            if (width <= 0 || height <= 0) {
                throw new JobExecutionException("Invalid size: width and height must be positive");
            }

            if (width > 2048 || height > 2048) {
                throw new JobExecutionException("Invalid size: maximum is 2048x2048");
            }

            return new int[]{width, height};

        } catch (NumberFormatException e) {
            throw new JobExecutionException("Invalid size format: " + sizeStr + " (expected: WxH, e.g., 16x16)");
        }
    }

    /**
     * Get MIME type from file path extension.
     *
     * @param path File path
     * @return MIME type
     */
    private String getMimeTypeFromPath(String path) {
        if (path == null) return "image/png";
        String lowerPath = path.toLowerCase();

        if (lowerPath.endsWith(".png")) return "image/png";
        if (lowerPath.endsWith(".jpg") || lowerPath.endsWith(".jpeg")) return "image/jpeg";
        if (lowerPath.endsWith(".gif")) return "image/gif";
        if (lowerPath.endsWith(".bmp")) return "image/bmp";
        if (lowerPath.endsWith(".webp")) return "image/webp";

        return "image/png"; // Default
    }

    /**
     * Find unique path by adding number suffix if path already exists.
     * <p>
     * Examples:
     * - textures/snow.png -> textures/snow-1.png (if snow.png exists)
     * - textures/snow-1.png -> textures/snow-2.png (if snow-1.png exists)
     * - textures/snow-2.png -> textures/snow-3.png (if snow-2.png exists)
     *
     * @param worldId World ID
     * @param path Original path
     * @return Unique path that doesn't exist yet
     */
    private String findUniquePath(WorldId worldId, String path) {
        // Check if original path exists
        if (!assetExists(worldId, path)) {
            return path;
        }

        // Split path into base and extension
        int lastDot = path.lastIndexOf('.');
        int lastSlash = path.lastIndexOf('/');

        String basePath;
        String extension;

        if (lastDot > lastSlash && lastDot > 0) {
            basePath = path.substring(0, lastDot);
            extension = path.substring(lastDot);
        } else {
            basePath = path;
            extension = "";
        }

        // Check if base path already ends with a number pattern (e.g., "snow-1")
        int currentNumber = 0;
        String baseWithoutNumber = basePath;

        // Match pattern: ends with "-NUMBER"
        if (basePath.matches(".*-\\d+$")) {
            int lastDash = basePath.lastIndexOf('-');
            String numberPart = basePath.substring(lastDash + 1);
            try {
                currentNumber = Integer.parseInt(numberPart);
                baseWithoutNumber = basePath.substring(0, lastDash);
            } catch (NumberFormatException e) {
                // Not a valid number, treat as regular base path
            }
        }

        // Find next available number
        int number = currentNumber == 0 ? 1 : currentNumber + 1;
        int maxAttempts = 1000; // Safety limit

        for (int i = 0; i < maxAttempts; i++) {
            String candidatePath = baseWithoutNumber + "-" + number + extension;

            if (!assetExists(worldId, candidatePath)) {
                log.info("Found unique path: {} -> {}", path, candidatePath);
                return candidatePath;
            }

            number++;
        }

        // Fallback: append timestamp
        String timestampPath = baseWithoutNumber + "-" + System.currentTimeMillis() + extension;
        log.warn("Could not find unique path after {} attempts, using timestamp: {}", maxAttempts, timestampPath);
        return timestampPath;
    }

    /**
     * Check if asset exists at given path.
     *
     * @param worldId World ID
     * @param path Asset path
     * @return true if asset exists
     */
    private boolean assetExists(WorldId worldId, String path) {
        try {
            Optional<SAsset> asset = assetService.findByPath(worldId, path);
            return asset.isPresent();
        } catch (Exception e) {
            log.debug("Error checking asset existence: {}", path, e);
            return false;
        }
    }

    /**
     * Archive the original generated image before any processing (crop/resize).
     * This preserves the unmodified AI-generated image for future reference.
     *
     * @param image Original generated image
     * @param path Asset path (used to generate archive path)
     */
    private void archiveOriginalImage(AiImage image, String path) {
        try {
            // Get image bytes
            byte[] imageBytes = image.getBytes();
            if (imageBytes == null || imageBytes.length == 0) {
                log.warn("Cannot archive original image: no bytes available for path {}", path);
                return;
            }

            // Generate archive path: append ".original" before extension
            String archivePath = generateArchivePath(path);

            log.info("Archiving original image: {} ({} bytes, {}x{})",
                    archivePath, imageBytes.length, image.getWidth(), image.getHeight());

            // Archive with WArchiveService
            ByteArrayInputStream inputStream = new ByteArrayInputStream(imageBytes);
            archiveService.archive(archivePath, inputStream);

            log.debug("Successfully archived original image: {}", archivePath);

        } catch (Exception e) {
            // Don't fail the job if archiving fails, just log the error
            log.error("Failed to archive original image for path: {}", path, e);
        }
    }

    /**
     * Make a specific color transparent in the image.
     * Useful for AI-generated images where DALL-E cannot create transparent backgrounds.
     * <p>
     * Supported colors:
     * - "true" or "black": Make black (and near-black) pixels transparent
     * - "white": Make white (and near-white) pixels transparent
     * - "blue": Make blue pixels transparent
     * - "red": Make red pixels transparent
     * - "green": Make green pixels transparent
     * <p>
     * Uses a threshold of 40 per RGB component to catch similar colors.
     *
     * @param image Original image
     * @param colorName Color name to make transparent
     * @param path Asset path for logging
     * @return Image with transparency applied
     * @throws JobExecutionException if processing fails
     */
    private AiImage makeColorTransparent(AiImage image, String colorName, String path)
            throws JobExecutionException {

        log.info("Making {} pixels transparent for path: {}", colorName, path);

        try {
            // Get image bytes
            byte[] originalBytes = image.getBytes();
            if (originalBytes == null || originalBytes.length == 0) {
                throw new JobExecutionException("Cannot make transparent: no image bytes available");
            }

            // Load image
            ByteArrayInputStream inputStream = new ByteArrayInputStream(originalBytes);
            BufferedImage originalImage = ImageIO.read(inputStream);

            if (originalImage == null) {
                throw new JobExecutionException("Cannot make transparent: failed to decode image");
            }

            int width = originalImage.getWidth();
            int height = originalImage.getHeight();

            // Create new image with alpha channel
            BufferedImage transparentImage = new BufferedImage(
                    width,
                    height,
                    BufferedImage.TYPE_INT_ARGB
            );

            // Determine target color RGB values
            int targetR, targetG, targetB;
            int threshold = 40; // Range for similar colors

            switch (colorName.toLowerCase()) {
                case "true":
                case "black":
                    targetR = 0; targetG = 0; targetB = 0;
                    break;
                case "white":
                    targetR = 255; targetG = 255; targetB = 255;
                    break;
                case "blue":
                    targetR = 0; targetG = 0; targetB = 255;
                    threshold = 60; // Wider range for color matching
                    break;
                case "red":
                    targetR = 255; targetG = 0; targetB = 0;
                    threshold = 60;
                    break;
                case "green":
                    targetR = 0; targetG = 255; targetB = 0;
                    threshold = 60;
                    break;
                default:
                    log.warn("Unknown transparency color '{}', skipping transparency", colorName);
                    return image;
            }

            log.debug("Making pixels transparent: target RGB=({},{},{}), threshold={}",
                    targetR, targetG, targetB, threshold);

            // Process each pixel
            int transparentCount = 0;
            for (int y = 0; y < height; y++) {
                for (int x = 0; x < width; x++) {
                    int rgb = originalImage.getRGB(x, y);

                    // Extract RGB components
                    int alpha = (rgb >> 24) & 0xFF;
                    int red = (rgb >> 16) & 0xFF;
                    int green = (rgb >> 8) & 0xFF;
                    int blue = rgb & 0xFF;

                    // Check if color matches target within threshold
                    boolean matches = Math.abs(red - targetR) <= threshold
                            && Math.abs(green - targetG) <= threshold
                            && Math.abs(blue - targetB) <= threshold;

                    if (matches) {
                        // Make transparent (alpha = 0)
                        transparentImage.setRGB(x, y, 0x00000000);
                        transparentCount++;
                    } else {
                        // Keep original pixel with full alpha
                        transparentImage.setRGB(x, y, (0xFF << 24) | (red << 16) | (green << 8) | blue);
                    }
                }
            }

            int totalPixels = width * height;
            float transparentPercent = (transparentCount * 100.0f) / totalPixels;
            log.info("Made {} pixels transparent ({:.1f}% of image)", transparentCount, transparentPercent);

            // Encode to bytes as PNG (PNG supports transparency)
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            ImageIO.write(transparentImage, "png", outputStream);
            byte[] transparentBytes = outputStream.toByteArray();

            // Create new AiImage with transparent data
            return AiImage.builder()
                    .bytes(transparentBytes)
                    .mimeType("image/png") // Force PNG for transparency support
                    .width(width)
                    .height(height)
                    .revisedPrompt(image.getRevisedPrompt())
                    .build();

        } catch (Exception e) {
            log.error("Failed to make color transparent: {}", colorName, e);
            throw new JobExecutionException("Failed to make color transparent: " + e.getMessage(), e);
        }
    }

    /**
     * Generate archive path by inserting ".original" before the file extension.
     * <p>
     * Examples:
     * - textures/blocks/stone.png -> textures/blocks/stone.original.png
     * - models/tree -> models/tree.original
     *
     * @param path Original asset path
     * @return Archive path with ".original" suffix
     */
    private String generateArchivePath(String path) {
        int lastDot = path.lastIndexOf('.');
        int lastSlash = path.lastIndexOf('/');

        if (lastDot > lastSlash && lastDot > 0) {
            // Has extension: insert before extension
            return path.substring(0, lastDot) + ".original" + path.substring(lastDot);
        } else {
            // No extension: append at end
            return path + ".original";
        }
    }
}
