package de.mhus.nimbus.world.generator.assets;

import de.mhus.nimbus.shared.service.SSettingsService;
import de.mhus.nimbus.shared.settings.SettingInteger;
import de.mhus.nimbus.shared.settings.SettingString;
import de.mhus.nimbus.shared.types.WorldId;
import de.mhus.nimbus.world.ai.image.AiImage;
import de.mhus.nimbus.world.ai.image.AiImageException;
import de.mhus.nimbus.world.ai.image.AiImageModel;
import de.mhus.nimbus.world.ai.image.AiImageOptions;
import de.mhus.nimbus.world.ai.model.AiModelService;
import de.mhus.nimbus.world.shared.job.JobExecutionException;
import de.mhus.nimbus.world.shared.job.JobExecutor;
import de.mhus.nimbus.world.shared.job.WJob;
import de.mhus.nimbus.world.shared.world.AssetMetadata;
import de.mhus.nimbus.world.shared.world.SAsset;
import de.mhus.nimbus.world.shared.world.SAssetService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import jakarta.annotation.PostConstruct;
import javax.imageio.ImageIO;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.util.Optional;

/**
 * Job executor that generates AI images for game assets.
 * Creates new images/textures based on text prompts and saves them to SAssets.
 * <p>
 * Job parameters:
 * <ul>
 *     <li>prompt (required) - Text description of the image</li>
 *     <li>path (required) - Asset path where image will be saved (e.g., "textures/blocks/stone.png")</li>
 *     <li>size (optional) - Image size in pixels (default: 16x16, format: "16x16")</li>
 *     <li>quality (optional) - Image quality: "standard" or "hd" (default: "standard")</li>
 *     <li>style (optional) - Image style: "vivid" or "natural" (default: "vivid")</li>
 *     <li>resize (optional) - Resize image to requested size if different (default: true)</li>
 *     <li>generateDescription (optional) - Generate AI description after saving (default: true)</li>
 *     <li>overwrite (optional) - Overwrite existing asset if path exists (default: false)</li>
 * </ul>
 * <p>
 * If overwrite=false and path already exists, a unique path will be generated by appending a number:
 * <ul>
 *     <li>textures/snow.png -> textures/snow-1.png (if snow.png exists)</li>
 *     <li>textures/snow-1.png -> textures/snow-2.png (if snow-1.png exists)</li>
 * </ul>
 */
@Component
@Slf4j
@RequiredArgsConstructor
public class AssetImageGeneratorExecutor implements JobExecutor {

    private static final String EXECUTOR_NAME = "asset-image-generator";
    private static final int DEFAULT_SIZE = 16;

    private final SAssetService assetService;
    private final AiModelService aiModelService;
    private final SSettingsService settingsService;
    private final AssetDescriptionGeneratorExecutor descriptionGenerator;

    @Value("${asset.image.ai-model:default:generate}")
    private String aiModelName;

    // AI image generation settings (loaded dynamically from SSettingsService)
    private SettingInteger timeoutSeconds;
    private SettingString defaultQuality;
    private SettingString defaultStyle;

    @PostConstruct
    private void initSettings() {
        timeoutSeconds = settingsService.getInteger("asset.image.timeout-seconds", 120);
        defaultQuality = settingsService.getString("asset.image.quality", "standard");
        defaultStyle = settingsService.getString("asset.image.style", "vivid");

        log.info("Asset image generation settings initialized: timeoutSeconds={}, quality={}, style={}",
                timeoutSeconds.get(), defaultQuality.get(), defaultStyle.get());
    }

    @Override
    public String getExecutorName() {
        return EXECUTOR_NAME;
    }

    @Override
    public JobResult execute(WJob job) throws JobExecutionException {
        try {
            // Get worldId from job
            String worldIdStr = job.getWorldId();
            if (worldIdStr == null || worldIdStr.isBlank()) {
                throw new JobExecutionException("Job has no worldId");
            }

            WorldId worldId = WorldId.of(worldIdStr)
                    .orElseThrow(() -> new JobExecutionException("Invalid worldId: " + worldIdStr));

            // Get required parameters
            String prompt = job.getParameters().get("prompt");
            if (prompt == null || prompt.isBlank()) {
                throw new JobExecutionException("Parameter 'prompt' is required");
            }

            String path = job.getParameters().get("path");
            if (path == null || path.isBlank()) {
                throw new JobExecutionException("Parameter 'path' is required");
            }

            // Get optional parameters
            String sizeStr = job.getParameters().getOrDefault("size", DEFAULT_SIZE + "x" + DEFAULT_SIZE);
            String quality = job.getParameters().getOrDefault("quality", defaultQuality.get());
            String style = job.getParameters().getOrDefault("style", defaultStyle.get());
            boolean resize = Boolean.parseBoolean(job.getParameters().getOrDefault("resize", "true"));
            boolean generateDescription = Boolean.parseBoolean(job.getParameters().getOrDefault("generateDescription", "true"));
            boolean overwrite = Boolean.parseBoolean(job.getParameters().getOrDefault("overwrite", "false"));

            // Find unique path if requested path already exists (unless overwrite=true)
            String uniquePath = path;
            if (!overwrite) {
                uniquePath = findUniquePath(worldId, path);
                if (!uniquePath.equals(path)) {
                    log.info("Path already exists, using unique path: {} -> {}", path, uniquePath);
                }
            } else if (assetExists(worldId, path)) {
                log.info("Overwriting existing asset at path: {}", path);
            }

            // Parse size
            int[] dimensions = parseSize(sizeStr);
            int width = dimensions[0];
            int height = dimensions[1];

            log.info("Generating image: world={}, path={}, prompt='{}', size={}x{}, quality={}, style={}",
                    worldId.getId(), uniquePath, prompt, width, height, quality, style);

            // Create AI image model
            AiImageOptions options = AiImageOptions.builder()
                    .width(width)
                    .height(height)
                    .quality(quality)
                    .style(style)
                    .responseFormat("url") // Download bytes for storage
                    .timeoutSeconds(timeoutSeconds.get())
                    .logRequests(false)
                    .build();

            Optional<AiImageModel> imageModelOpt = aiModelService.createImageModel(aiModelName, options);
            if (imageModelOpt.isEmpty()) {
                throw new JobExecutionException("Failed to create AI image model: " + aiModelName);
            }

            AiImageModel imageModel = imageModelOpt.get();
            log.info("Using AI image model: {}", imageModel.getName());

            // Generate image
            AiImage image = generateImage(imageModel, prompt, width, height);

            // Resize image if needed and requested
            if (resize) {
                image = resizeImageIfNeeded(image, width, height, uniquePath);
            }

            // Save to SAssets
            SAsset savedAsset = saveImage(worldId, uniquePath, image, prompt);
            savedAsset.getPublicData().setSource("generated");
            savedAsset.getPublicData().setAuthor("nimbus"); // TODO from settings
            savedAsset.getPublicData().setLicense("nimbus license"); // TODO from settings
            savedAsset.getPublicData().setLicenseFixed(true);
            assetService.updateMetadata(savedAsset, savedAsset.getPublicData());

            // Generate AI description if requested
            if (generateDescription) {
                generateAssetDescription(savedAsset);
            }

            String message = String.format("Generated image: %s (%dx%d) - '%s'",
                    uniquePath, width, height, prompt);
            log.info(message);
            return JobResult.success(message);

        } catch (Exception e) {
            log.error("Image generation failed", e);
            throw new JobExecutionException("Generation failed: " + e.getMessage(), e);
        }
    }

    /**
     * Generate image using AI image model.
     *
     * @param imageModel AI image model
     * @param prompt Text description
     * @param width Image width
     * @param height Image height
     * @return Generated image
     * @throws JobExecutionException if generation fails
     */
    private AiImage generateImage(AiImageModel imageModel, String prompt, int width, int height)
            throws JobExecutionException {
        try {
            // Enhance prompt for game texture/images
            String enhancedPrompt = enhancePromptForGameTexture(prompt, width, height);
            log.debug("Enhanced prompt: {}", enhancedPrompt);

            // Generate image
            AiImage image = imageModel.generate(enhancedPrompt, width, height);

            if (image == null) {
                throw new JobExecutionException("AI model returned null image");
            }

            // Check if we have image data
            if (!image.hasBytes() && !image.hasUrl()) {
                throw new JobExecutionException("Generated image has no data (neither bytes nor URL)");
            }

            return image;

        } catch (AiImageException e) {
            log.error("Failed to generate image: prompt={}", prompt, e);
            throw new JobExecutionException("Image generation failed: " + e.getMessage(), e);
        }
    }

    /**
     * Generate AI description for the saved asset.
     *
     * @param asset The saved asset
     */
    private void generateAssetDescription(SAsset asset) {
        try {
            log.info("Generating AI description for asset: {}", asset.getPath());

            boolean success = descriptionGenerator.generateDescriptionForAsset(asset);

            if (success) {
                log.info("Successfully generated description for asset: {}", asset.getPath());
            } else {
                log.warn("Failed to generate description for asset: {}", asset.getPath());
            }

        } catch (Exception e) {
            log.error("Error generating description for asset: {}", asset.getPath(), e);
            // Don't throw exception - description generation is optional
        }
    }

    /**
     * Save generated image to SAssets.
     *
     * @param worldId World ID
     * @param path Asset path
     * @param image Generated image
     * @param originalPrompt Original generation prompt
     * @return Saved asset
     * @throws JobExecutionException if save fails
     */
    private SAsset saveImage(WorldId worldId, String path, AiImage image, String originalPrompt) throws JobExecutionException {
        try {
            // Get image bytes
            byte[] imageBytes = image.getBytes();
            if (imageBytes == null || imageBytes.length == 0) {
                throw new JobExecutionException("No image bytes available");
            }

            // Read actual image dimensions from bytes
            ByteArrayInputStream dimCheckStream = new ByteArrayInputStream(imageBytes);
            BufferedImage bufferedImage = ImageIO.read(dimCheckStream);

            if (bufferedImage == null) {
                throw new JobExecutionException("Failed to decode image bytes");
            }

            int actualWidth = bufferedImage.getWidth();
            int actualHeight = bufferedImage.getHeight();

            log.debug("Image dimensions: requested={}x{}, actual={}x{}",
                    image.getWidth(), image.getHeight(), actualWidth, actualHeight);

            // Determine MIME type
            String mimeType = image.getMimeType();
            if (mimeType == null || mimeType.isBlank()) {
                // Fallback: detect from path
                mimeType = getMimeTypeFromPath(path);
            }

            // Create asset metadata
            AssetMetadata metadata = new AssetMetadata();

            // Set description (use revised prompt if available)
            if (image.getRevisedPrompt() != null && !image.getRevisedPrompt().isBlank()) {
                metadata.setDescription("AI-generated image: " + image.getRevisedPrompt());
            } else {
                metadata.setDescription("AI-generated image");
            }

            metadata.setMimeType(mimeType);
            metadata.setWidth(actualWidth);
            metadata.setHeight(actualHeight);
            metadata.setSource("AI Generated");
            metadata.setAuthor("DALL-E");

            // Store original prompt as custom property
            if (originalPrompt != null && !originalPrompt.isBlank()) {
                metadata.setProperty("prompt", originalPrompt);
            }

            // Create asset
            ByteArrayInputStream inputStream = new ByteArrayInputStream(imageBytes);
            SAsset asset = assetService.saveAsset(worldId, path, inputStream, "AI-Generator", metadata);

            if (asset == null) {
                throw new JobExecutionException("Asset service returned null");
            }

            log.info("Saved image to assets: path={}, size={} bytes, dimensions={}x{}, mimeType={}, assetId={}",
                    path, imageBytes.length, actualWidth, actualHeight, mimeType, asset.getId());

            return asset;

        } catch (Exception e) {
            log.error("Failed to save image: path={}", path, e);
            throw new JobExecutionException("Failed to save image: " + e.getMessage(), e);
        }
    }

    /**
     * Resize image if dimensions don't match requested size.
     *
     * @param image Original image
     * @param targetWidth Target width
     * @param targetHeight Target height
     * @param path Asset path for logging
     * @return Resized image or original if already correct size
     * @throws JobExecutionException if resize fails
     */
    private AiImage resizeImageIfNeeded(AiImage image, int targetWidth, int targetHeight, String path)
            throws JobExecutionException {

        // Check if resize is needed
        if (image.getWidth() == targetWidth && image.getHeight() == targetHeight) {
            log.debug("Image already has correct size: {}x{}", targetWidth, targetHeight);
            return image;
        }

        log.info("Resizing image from {}x{} to {}x{} for path: {}",
                image.getWidth(), image.getHeight(), targetWidth, targetHeight, path);

        try {
            // Get image bytes
            byte[] originalBytes = image.getBytes();
            if (originalBytes == null || originalBytes.length == 0) {
                throw new JobExecutionException("Cannot resize: no image bytes available");
            }

            // Load image
            ByteArrayInputStream inputStream = new ByteArrayInputStream(originalBytes);
            BufferedImage originalImage = ImageIO.read(inputStream);

            if (originalImage == null) {
                throw new JobExecutionException("Cannot resize: failed to decode image");
            }

            // Resize image
            Image scaledImage = originalImage.getScaledInstance(
                    targetWidth,
                    targetHeight,
                    Image.SCALE_SMOOTH
            );

            // Convert to BufferedImage
            BufferedImage resizedImage = new BufferedImage(
                    targetWidth,
                    targetHeight,
                    BufferedImage.TYPE_INT_ARGB
            );
            resizedImage.getGraphics().drawImage(scaledImage, 0, 0, null);

            // Encode to bytes
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            String format = getImageFormat(image.getMimeType());
            ImageIO.write(resizedImage, format, outputStream);
            byte[] resizedBytes = outputStream.toByteArray();

            // Create new AiImage with resized data
            return AiImage.builder()
                    .bytes(resizedBytes)
                    .mimeType(image.getMimeType())
                    .width(targetWidth)
                    .height(targetHeight)
                    .revisedPrompt(image.getRevisedPrompt())
                    .build();

        } catch (Exception e) {
            log.error("Failed to resize image: {}x{} -> {}x{}",
                    image.getWidth(), image.getHeight(), targetWidth, targetHeight, e);
            throw new JobExecutionException("Failed to resize image: " + e.getMessage(), e);
        }
    }

    /**
     * Get image format from MIME type.
     *
     * @param mimeType MIME type
     * @return Image format (e.g., "png", "jpeg")
     */
    private String getImageFormat(String mimeType) {
        if (mimeType == null) return "png";

        if (mimeType.contains("png")) return "png";
        if (mimeType.contains("jpeg") || mimeType.contains("jpg")) return "jpeg";
        if (mimeType.contains("gif")) return "gif";
        if (mimeType.contains("bmp")) return "bmp";
        if (mimeType.contains("webp")) return "webp";

        return "png"; // Default
    }

    /**
     * Enhance prompt for game image generation.
     * Adds context about tileable textures, pixel art, and game assets.
     *
     * @param prompt Original prompt
     * @param width Image width
     * @param height Image height
     * @return Enhanced prompt
     */
    private String enhancePromptForGameTexture(String prompt, int width, int height) {
        StringBuilder enhanced = new StringBuilder();

        // Add texture-specific context
        if (width <= 64 && height <= 64) {
            // Small textures - pixel art style
            enhanced.append("Pixel art game texture/image, ");
            enhanced.append(width).append("x").append(height).append(" pixels, ");
            enhanced.append("tileable seamless pattern, ");
        } else {
            // Larger textures
            enhanced.append("Game texture, ");
            enhanced.append("tileable seamless pattern, ");
            enhanced.append(width).append("x").append(height).append(" resolution, ");
        }

        // Add original prompt
        enhanced.append(prompt);

        // Add additional requirements
        enhanced.append(". Clean, clear, no borders, suitable for tiling.");

        return enhanced.toString();
    }

    /**
     * Parse size string (e.g., "16x16", "512x512").
     *
     * @param sizeStr Size string
     * @return Array with [width, height]
     * @throws JobExecutionException if format is invalid
     */
    private int[] parseSize(String sizeStr) throws JobExecutionException {
        try {
            String[] parts = sizeStr.toLowerCase().split("x");
            if (parts.length != 2) {
                throw new JobExecutionException("Invalid size format: " + sizeStr + " (expected: WxH, e.g., 16x16)");
            }

            int width = Integer.parseInt(parts[0].trim());
            int height = Integer.parseInt(parts[1].trim());

            if (width <= 0 || height <= 0) {
                throw new JobExecutionException("Invalid size: width and height must be positive");
            }

            if (width > 2048 || height > 2048) {
                throw new JobExecutionException("Invalid size: maximum is 2048x2048");
            }

            return new int[]{width, height};

        } catch (NumberFormatException e) {
            throw new JobExecutionException("Invalid size format: " + sizeStr + " (expected: WxH, e.g., 16x16)");
        }
    }

    /**
     * Get MIME type from file path extension.
     *
     * @param path File path
     * @return MIME type
     */
    private String getMimeTypeFromPath(String path) {
        if (path == null) return "image/png";
        String lowerPath = path.toLowerCase();

        if (lowerPath.endsWith(".png")) return "image/png";
        if (lowerPath.endsWith(".jpg") || lowerPath.endsWith(".jpeg")) return "image/jpeg";
        if (lowerPath.endsWith(".gif")) return "image/gif";
        if (lowerPath.endsWith(".bmp")) return "image/bmp";
        if (lowerPath.endsWith(".webp")) return "image/webp";

        return "image/png"; // Default
    }

    /**
     * Find unique path by adding number suffix if path already exists.
     * <p>
     * Examples:
     * - textures/snow.png -> textures/snow-1.png (if snow.png exists)
     * - textures/snow-1.png -> textures/snow-2.png (if snow-1.png exists)
     * - textures/snow-2.png -> textures/snow-3.png (if snow-2.png exists)
     *
     * @param worldId World ID
     * @param path Original path
     * @return Unique path that doesn't exist yet
     */
    private String findUniquePath(WorldId worldId, String path) {
        // Check if original path exists
        if (!assetExists(worldId, path)) {
            return path;
        }

        // Split path into base and extension
        int lastDot = path.lastIndexOf('.');
        int lastSlash = path.lastIndexOf('/');

        String basePath;
        String extension;

        if (lastDot > lastSlash && lastDot > 0) {
            basePath = path.substring(0, lastDot);
            extension = path.substring(lastDot);
        } else {
            basePath = path;
            extension = "";
        }

        // Check if base path already ends with a number pattern (e.g., "snow-1")
        int currentNumber = 0;
        String baseWithoutNumber = basePath;

        // Match pattern: ends with "-NUMBER"
        if (basePath.matches(".*-\\d+$")) {
            int lastDash = basePath.lastIndexOf('-');
            String numberPart = basePath.substring(lastDash + 1);
            try {
                currentNumber = Integer.parseInt(numberPart);
                baseWithoutNumber = basePath.substring(0, lastDash);
            } catch (NumberFormatException e) {
                // Not a valid number, treat as regular base path
            }
        }

        // Find next available number
        int number = currentNumber == 0 ? 1 : currentNumber + 1;
        int maxAttempts = 1000; // Safety limit

        for (int i = 0; i < maxAttempts; i++) {
            String candidatePath = baseWithoutNumber + "-" + number + extension;

            if (!assetExists(worldId, candidatePath)) {
                log.info("Found unique path: {} -> {}", path, candidatePath);
                return candidatePath;
            }

            number++;
        }

        // Fallback: append timestamp
        String timestampPath = baseWithoutNumber + "-" + System.currentTimeMillis() + extension;
        log.warn("Could not find unique path after {} attempts, using timestamp: {}", maxAttempts, timestampPath);
        return timestampPath;
    }

    /**
     * Check if asset exists at given path.
     *
     * @param worldId World ID
     * @param path Asset path
     * @return true if asset exists
     */
    private boolean assetExists(WorldId worldId, String path) {
        try {
            Optional<SAsset> asset = assetService.findByPath(worldId, path);
            return asset.isPresent();
        } catch (Exception e) {
            log.debug("Error checking asset existence: {}", path, e);
            return false;
        }
    }
}
